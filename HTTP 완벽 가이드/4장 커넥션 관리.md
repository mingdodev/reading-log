# 4. 커넥션 관리

❗️ **TO DO**

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

<br>

## 4.1 TCP 커넥션

- TCP의 특징은 신뢰성 있는 안전한 전달
- URL 획득 후
    - 호스트 추출
    - 호스트에 대한 IP주소와 포트 번호 획득
    - 이에 대한 TCP 커넥션 생성
- 신뢰할 만한 통신 = 바이트들이 순서에 맞게 정확히 전달됨

- TCP 스트림은 세그먼트로 나뉘어 IP 패킷(혹은 데이터그램)을 통해 전송된다.
    - TCP가 데이터 스트림을 세그먼트라는 단위로 잘게 나눈 뒤 패킷에 담아 인터넷을 통해 데이터 전달
    - HTTPS가 HTTP에 보안 계층이 추가된 것 (TLS or SSL)

- 포트 번호를 통해 TCP 커넥션 여러 개를 유지

- TCP 소켓 프로그래밍
    - 소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
    - TCP API는 모든 세부사항을 외부로부터 숨긴다.
    - 커넥션 생성은 서버와의 거리, 서버의 부하, 인터넷 혼잡도에 따라 시간이 걸림

## 4.2 TCP 성능에 대한 고려

- HTTP의 성능에 영향을 미침

### HTTP 트랜잭션 지연

- 트랜잭션 처리 시간은 짧다. 대부분의 지연은 TCP 네트워크 지연에 의한 것이다.
- 지연 원인
    - DNS 이름 분석 인프라를 사용하여 URI의 호스트 명을 IP 주소로 변환하는 데 수십 초나 걸림 (최근 방문 기록 없다면)
    - 커넥션 설정 시간
    - 요청 메시지가 전달되고 서버에 의해 처리되는 시간
    - 서버가 응답을 보내는 시간

### ❗️ 프로그래머에게 영향을 주는 성능 관련 주요 요소

- **TCP 커넥션의 핸드셰이크 설정**
    - SYN / SYN+ACK로 연결 설정하는 과정이 눈에 띄는 지연을 발생시킴
    - AKC 메시지는 보통 HTTP 메시지 전체를 전달할 수 있을 만큼 크고, 많은 서버 응답 메시지는 하나의 IP 패킷에 담길 수 있을 정도임 -> 작은 메시지들이 연결을 위해 왔다갔다.. 낭비란 뜻~
    - 해결 방안은 이미 존재하는 커넥션을 재활용하는 것인듯?

- **TCP piggyback acknowledgement를 위한 확인응답 지연 알고리즘**
    - TCP의 성공적인 데이터 전송 보장에서 나오는 지연
    - TCP segment가 가지는 순번과 데이터 무결성 체크섬

    - 작은 확인 응답 패킷들. 따라서 같은 방향으로 송출되는 패킷들에 확인응답을 piggyback시킨다.
        - 먼저 편승할 패킷들을 찾고 없으면 개별적으로 전송한다.
    - 하지만 HTTP 동작 방식은 요청-응답 두 가지로 이뤄지기 때문에 편승할 패킷이 거의 없다.
        - 따라서 확인응답 지연 알고리즘으로 인한 지연이 자주 발생한다. (차라리 경우에 따라 비활성화하는 게 나을지도.. 수정도 가능함. TCP 스택에 있는 매개변수 수정으로)
        - 단, TCP 설정을 수정할 때는 TCP 내부 알고리즘이 피하려고 했던 문제들을 애플리케이션이 발생시키지 않을 것이라는 확신 아래에서 수정해야 한다.

- **TCP Slow start**
    - TCP 커넥션은 시간이 지날수록 튜닝된다.
    - 처음엔 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높인다.
    - 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 쓰인다.

    - **Opening the congestion window**
        - TCP가 한번에 전송할 수 있는 패킷의 수를 제한
        - 성공하면(확인 응답을 받으면) 추가로 패킷을 전송할 수 있는 권한 획득
        - additive or exponential?

    - 따라서 새로운 커넥션은 이미 어느 정도 데이터를 주고받은 튜닝된 커넥션보다 느리다.
        - *HTTP에는 (더 빠른) 튜닝된 커넥션을 재사용하는 기능이 있다.*

- **데이터를 한데 모아 한 번에 전송하기 위한 Nagle Algorithm**
    - 애플리케이션이 어떤 크기의 데이터든지 TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공한다.
        - 하지만 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하므로 *너무 작은 패킷을 포함한* 많은 수의 패킷을 전송하면 네트워크 성능이 크게 떨어지게 되는 문제가 있다.

    - 따라서 네이글 알고리즘은 패킷을 전송하기 전 많은 양의 TCP 데이터를 한 덩어리로 합친다.
    - 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다.
        - 다만 다른 모든 패킷이 응답을 확인응답을 받았으면 전송을 허락함
        - 그게 아니라면 데이터는 버퍼에 저장됨 -> 확인응답을 기다리던 패킷이 응답을 받았거나 / 전송하기 충분할 만큼 쌓였을 때 데이터 전송!

    - **문제점**
        - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하므로 생길지 안 생길지 모르는 추가 데이터를 기다리며 **지연 발생**
        - 확인응답 지연 알고리즘과 함께 사용하면 형편없음. 확인응답이 도착할 때까지 데이터 전송을 멈추는데.. 확인응답 지연 알고리즘은 확인응답을 100~200 밀리초 지연시킴.

    - `TCP_NODELAY` parameter로 네이글 알고리즘을 비활성화할 수 있다.
        - 만약 그러면 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들 것!


- **TIME_WAIT 누적과 포트 고갈**
    - TCP 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리에 기록해 둔다.
    - 이를 통해 일정 시간 동안 같은 주소와 포트 번호를 사용하는 새로운 커넥션이 생성되지 않게 한다.
        - 보통 세그먼트 생명주기의 두 배 2MSL(2분) 정도
        - 이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 문제 방지

    - 현대의 빠른 라우터들 덕분에 커넥션이 닫힌 후 중복되는 패킷이 생기는 경우는 거의 없어졌다.
    - 보통은 이 커넥션 종료 지연이 문제가 되지 않지만 성능 시험을 할 때는 문제가 될 수도
        - 클라이언트가 접속할 수 있는 IP 주소 개수를 제한하고 서버는 고정
        - 클라이언트의 포트 번호만 변경이 가능한데, TIME_WAIT가 있다면 순간순간 포트를 재활용하는 것이 어려움. 따라서 커넥션이 제한됨. (서버가 초당 500개 이상의 트랜잭션을 처리할 만큼 빠르지 않다면..)

    - 이를 해결하기 위해 부하를 생성하는 장비를 더 많이 사용하거나 여러 개의 가상 IP 주소 사용 가능
    - 포트 고갈 문제가 아니더라도 커넥션을 너무 많이 맺거나 대기 상태로 있는 제어 블록이 너무 많아지는 상황은 주의해야 함!! 운영체제에 따라 극심한 지연을 겪을수도.

## 4.3 HTTP 커넥션 관리

### 흔히 잘못 이해하는 HTTP Connection Header

- HTTP 메시지는 클라이언트-서버 (사이의 서버-프락시, 캐시 서버)까지 중개 서버들을 하나하나 거치며 전달된다.
- 어떤 경우, *두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용할 옵션을 지정*해야 한다.

- HTTP 커넥션 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며 그 값은 다른 커넥션에 전달되지 않음
- 커넥션 헤더에는 다음 세 가지 종류의 토큰이 전달될 수 있어 혼란..
    - HTTP 헤더 필드명 (이 커넥션에만 해당되는 헤더들을 나열)
    - 임시적인 토큰 값 (커넥션에 대한 비표준 옵션)
    - close 값 (커넥션이 작업이 완료되면 종료되어야 함을 의미)

    **e.g.** `Connection: meter, close, bill-my-credit-card`
        `Meter: ~~`
    - Connection 헤더는, Meter 헤더를 다른 커넥션으로 전달하면 안 되고
    - bill-my-credit-card 옵션을 적용할 것이며
    - 이 트랜잭션이 끝나면 커넥션이 끊길 것이라고 말함

    - 커넥션 헤더에는 hop-by-hop(홉별) 헤더 명을 기술함 -> 헤더 보호하기
    - 커넥션 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 한다!
    - 커넥션 헤더에 기술되어 있지 않더라도 홉별 헤더인 것들도 있음
        - proxy-authentic, proxy-connection, transfer-encoding, upgrade...


### HTTP Connection 최적화 기술

- 커넥션 관리가 잘 안 되면 TCP 성능이 매우 안 좋아질 수 있음
- 순차적인 트랜잭션 처리에 의한 지연 문제 (1)
    - **ex.** 예를 들어 3개의 이미지가 있는 웹 페이지가 있다. 브라우저가 이 페이지를 보여주려면 네 개의 HTTP 트랜잭션을 만들어야 함. 해당 HTML을 받기 위한 하나, 첨부된 이미지를 받기 위한 세 개. **각 트랜잭션이 전부 새로운 커넥션을 필요로 한다면 연결 지연과 함께 느린 시작 지연이 매번 발생할 것.**

- 순차적인 처리로 인한 지연은 물리적 지연뿐만 아니라, 하나의 이미지를 받는 도중 웹페이지의 나머지 공간에 아무런 변화가 없어서 느껴지는 *심리적 지연*도 있다. (오히려 전체 시간이 느려도 세 개가 동시에 로드되는 걸 더 빠르다고 느낌)

- 순차적인 트랜잭션 처리에 의한 지연 문제 (2)
    - 특정 브라우저의 경우 객체를 화면에 배치하려면 객체의 크기를 알아야 함. 따라서 모든 객체를 내려받기 전에는 화면이 텅~

<**❗️ HTTP 커넥션 성능을 향상시키는 최신 기술 네 가지**>

- **병렬 커넥션**
    - 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청

- **지속 커넥션**
    - 커넥션을 맺고 끊을 때 발생하는 지연을 제거하기 위한 커넥션 재활용

- **파이프라인 커넥션**
    - 공유 TCP 커넥션을 통한 병렬 HTTP 요청

- **다중 커넥션**
    - 요청과 응답들에 대한 중재
    - 실험적인 기술임

## 4.4 병렬 커넥션

## 4.5 지속 커넥션

## 4.6 파이프라인 커넥션

## 4.7 커넥션 끊기에 대한 미스터리