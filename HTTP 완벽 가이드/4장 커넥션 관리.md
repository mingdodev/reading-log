# 4. 커넥션 관리

❗️ **TO DO**

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

<br>

## 4.1 TCP 커넥션

- TCP의 특징은 신뢰성 있는 안전한 전달
- URL 획득 후
    - 호스트 추출
    - 호스트에 대한 IP주소와 포트 번호 획득
    - 이에 대한 TCP 커넥션 생성
- 신뢰할 만한 통신 = 바이트들이 순서에 맞게 정확히 전달됨

- TCP 스트림은 세그먼트로 나뉘어 IP 패킷(혹은 데이터그램)을 통해 전송된다.
    - TCP가 데이터 스트림을 세그먼트라는 단위로 잘게 나눈 뒤 패킷에 담아 인터넷을 통해 데이터 전달
    - HTTPS가 HTTP에 보안 계층이 추가된 것 (TLS or SSL)

- 포트 번호를 통해 TCP 커넥션 여러 개를 유지

- TCP 소켓 프로그래밍
    - 소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
    - TCP API는 모든 세부사항을 외부로부터 숨긴다.
    - 커넥션 생성은 서버와의 거리, 서버의 부하, 인터넷 혼잡도에 따라 시간이 걸림

## 4.2 TCP 성능에 대한 고려

- HTTP의 성능에 영향을 미침

### HTTP 트랜잭션 지연

- 트랜잭션 처리 시간은 짧다. 대부분의 지연은 TCP 네트워크 지연에 의한 것이다.
- 지연 원인
    - DNS 이름 분석 인프라를 사용하여 URI의 호스트 명을 IP 주소로 변환하는 데 수십 초나 걸림 (최근 방문 기록 없다면)
    - 커넥션 설정 시간
    - 요청 메시지가 전달되고 서버에 의해 처리되는 시간
    - 서버가 응답을 보내는 시간

### ❗️ 프로그래머에게 영향을 주는 성능 관련 주요 요소

- **TCP 커넥션의 핸드셰이크 설정**
    - SYN / SYN+ACK로 연결 설정하는 과정이 눈에 띄는 지연을 발생시킴
    - AKC 메시지는 보통 HTTP 메시지 전체를 전달할 수 있을 만큼 크고, 많은 서버 응답 메시지는 하나의 IP 패킷에 담길 수 있을 정도임 -> 작은 메시지들이 연결을 위해 왔다갔다.. 낭비란 뜻~
    - 해결 방안은 이미 존재하는 커넥션을 재활용하는 것인듯?

- **TCP piggyback acknowledgement를 위한 확인응답 지연 알고리즘**
    - TCP의 성공적인 데이터 전송 보장에서 나오는 지연
    - TCP segment가 가지는 순번과 데이터 무결성 체크섬

    - 작은 확인 응답 패킷들. 따라서 같은 방향으로 송출되는 패킷들에 확인응답을 piggyback시킨다.
        - 먼저 편승할 패킷들을 찾고 없으면 개별적으로 전송한다.
    - 하지만 HTTP 동작 방식은 요청-응답 두 가지로 이뤄지기 때문에 편승할 패킷이 거의 없다.
        - 따라서 확인응답 지연 알고리즘으로 인한 지연이 자주 발생한다. (차라리 경우에 따라 비활성화하는 게 나을지도.. 수정도 가능함. TCP 스택에 있는 매개변수 수정으로)
        - 단, TCP 설정을 수정할 때는 TCP 내부 알고리즘이 피하려고 했던 문제들을 애플리케이션이 발생시키지 않을 것이라는 확신 아래에서 수정해야 한다.

- **TCP Slow start**
    - TCP 커넥션은 시간이 지날수록 튜닝된다.
    - 처음엔 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높인다.
    - 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 쓰인다.

    - **Opening the congestion window**
        - TCP가 한번에 전송할 수 있는 패킷의 수를 제한
        - 성공하면(확인 응답을 받으면) 추가로 패킷을 전송할 수 있는 권한 획득
        - additive or exponential?

    - 따라서 새로운 커넥션은 이미 어느 정도 데이터를 주고받은 튜닝된 커넥션보다 느리다.
        - *HTTP에는 (더 빠른) 튜닝된 커넥션을 재사용하는 기능이 있다.*

- **데이터를 한데 모아 한 번에 전송하기 위한 Nagle Algorithm**
    - 애플리케이션이 어떤 크기의 데이터든지 TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공한다.
        - 하지만 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하므로 *너무 작은 패킷을 포함한* 많은 수의 패킷을 전송하면 네트워크 성능이 크게 떨어지게 되는 문제가 있다.

    - 따라서 네이글 알고리즘은 패킷을 전송하기 전 많은 양의 TCP 데이터를 한 덩어리로 합친다.
    - 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다.
        - 다만 다른 모든 패킷이 응답을 확인응답을 받았으면 전송을 허락함
        - 그게 아니라면 데이터는 버퍼에 저장됨 -> 확인응답을 기다리던 패킷이 응답을 받았거나 / 전송하기 충분할 만큼 쌓였을 때 데이터 전송!

    - **문제점**
        - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하므로 생길지 안 생길지 모르는 추가 데이터를 기다리며 **지연 발생**
        - 확인응답 지연 알고리즘과 함께 사용하면 형편없음. 확인응답이 도착할 때까지 데이터 전송을 멈추는데.. 확인응답 지연 알고리즘은 확인응답을 100~200 밀리초 지연시킴.

    - `TCP_NODELAY` parameter로 네이글 알고리즘을 비활성화할 수 있다.
        - 만약 그러면 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들 것!


- **TIME_WAIT 지연과 포트 고갈**

## 4.3 HTTP 커넥션 관리

## 4.4 병렬 커넥션

## 4.5 지속 커넥션

## 4.6 파이프라인 커넥션

## 4.7 커넥션 끊기에 대한 미스터리