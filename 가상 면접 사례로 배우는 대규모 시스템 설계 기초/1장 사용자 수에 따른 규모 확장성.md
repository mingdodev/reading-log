## 캐시

> 자주 변경되지 않고, 변경이 사용자의 의사 결정에 깊이 관여하지 않는 데이터를 캐시에 두어야 한다고 생각한다. 최근 데이터의 전체 목록을 조회하고 특정 키워드를 검색하는 API에 캐시를 도입했는데, 과연 '검색'에 캐시가 어울리는지 끝까지 고민이 있다. '검색'은 사용자 행동에 대한 목적이 뚜렷한데 캐시로 인해 동기화되지 않은 데이터를 보여줘도 괜찮은 것일까? 고민 끝에, **검색 결과가 없는 경우** 사용자는 데이터로 인해 의사 결정에 큰 영향을 받을 것이라 판단하여 그런 경우에 대해서만 TTL을 짧게 설정하는 것으로 결정했다. 0에서 1이 되는 것은 빨리 빨리 이뤄져야 한다는 생각으로!

- 캐시가 SPOF로 작용하지 않게 캐시 서버를 분산시켜야 한다.

- 캐시 메모리 과할당으로 잦은 eviction으로 인한 성능 저하를 막기

- eviction 정책에 대한 설계 필요

## 메시지 큐

- 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌ㅌ트

- 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

- 생산자는 소비자가 다운되어도 메시지를 발행할 수 있고, 소비자는 생산자 서비스가 가용 상태가 아니라도 메시지를 받을 수 있다.

- 큐의 크기가 커지면 처리기 프로세스가 더 많이 필요, 그러나 큐가 거의 항상 비어있는 상태면 처리기 프로세스의 수를 줄일 수 있다. -> 생산자와 소비자 서비스의 규모가 독립적으로 확장된다.

## 로그, 메트릭 그리고 자동화

- 대규모일수록 중요해지는 것들

-  로그: 에러 로그를 서버 별로 보는 것도 좋지만 한 번에 모아 볼 수 있는 서비스 있음 굿

> 저번 프로젝트에서 Datadog을 도입했을 때, 소규모이지만 DB와 애플리케이션 에러 로그를 한 번에 확인할 수 있어 디버깅이 훨씬 편했다.

- 유용한 메트릭

    - 호스트 단위 메트릭: CPU, Memory, Disk I/O

    - 종합 메트릭: DB 계층 성능, 캐시 계층의 성능

    - 핵심 비즈니스 메트릭: DAU, revenue, retention

- 자동화: 통합, 빌드, 테스트, 배포

> 테스트 자동화가 주는 안정감, 수동 테스트의 무지막지한 비효율!! 테스트를 설계하면 모듈들이 서로 얼마나 의존하고 있는지 더 잘 보인다는 걸 느꼈다. 중요성을 느끼는 만큼 테스트 작성을 귀찮아하지 말자~!

## 데이터베이스의 수평적 확장

성능 확장의 한계, SPOF, 비용 문제로 수직적 확장에는 한계가 있다.

- **샤딩**: 샤드에 저장되는 데이터에는 중복이 없다.

#### 샤딩 전략 구현: **샤딩 키**를 어떻게 정하냐?

- 샤딩 키 = 파티션 키: 데이터가 어떻게 분산될 지 정하기

> 불필요한 탐색을 줄인다는 점에서는 인덱스랑 비슷한 느낌

1. 샤드에 데이터가 균일하게 분배되어야 함

2. 샤드에 데이터가 쌓이는 속도도 비슷 = 다 차는 시점이 비슷

이런 조건을 만족하는 키를 잘 선택해야!

##### 샤딩에 문제가 생기는 경우

- 유명인사 문제. 적절한 샤드 쪼개기와 분배 필요.

- 너무 많이 쪼개는 경우 조인의 어려움 문제 -> 비정규화

- 샤드 내 데이터 양이 하나로 감당이 안 되거나 샤드들 중 하나가 먼저 다 차면 재샤딩 (샤드 키 계싼 함수 변경, 데이터 재배치) -> 안정 해시 활용 (5장에 등장)