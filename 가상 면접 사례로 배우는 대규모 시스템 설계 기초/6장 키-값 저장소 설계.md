## 키-값 저장소

- 키는 짧을수록 좋다.

- 값은 무엇(리스트, 객체, 문자열 등)이 오든 상관하지 않는다.

#### 문제 이해 및 설계 범위 확정

**읽기, 쓰기 그리고 메모리 사용량 사이 균형**과 **데이터의 일관성과 가용성 사이 타협**

- 예를 들어, 키-값 쌍의 크기는 10KB 이하이며 큰 데이터 저장이 가능해야 하고, 가용성/규모 확장성을 제공해야 하며 latency가 짧아야 한다는 특성을 설계

#### 분산 키-값 저장소

메모리에 해시 테이블로 저장하는 단일 서버 키-값 저장소는 모든 데이터를 메모리에 저장할 수 없다는 약점 존재. 데이터를 압축하거나 디스크를 함께 사용하는 방법이 있지만, 한 대의 서버는 한계가 있다.

##### CAP 정리

데이터 일관성, 가용성, 파티션 감내를 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다.

> 파티션은 두 노드 사이 통신 장애를 말하며, 파티션 감내는 파티션이 발생하더라도 시스템이 계속 동작해야 함을 의미한다.

> 예를 들어, 은행권에서는 데이터 일관성이, 상품 전시 도메인에서는 가용성이 우선일 것이다.

## 시스템 컴포넌트

#### 데이터 파티션

데이터를 분할하여 여러 대 서버에 저장하는 것. 데이터를 고르게 분산할 수 있고, 노드의 변경(추가/삭제)에 데이터 이동이 최소화되는 설계 필요.

#### 데이터 다중화

가용성 확보를 위해 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있음. 해시 링으로 구현 가능.

#### 일관성

다중화된 데이터들 간 일관성이 보장되어야 함. **정족수 합의 프로토콜**은 N(사본 개수), W(쓰기 개수), R(읽기 개수)로 일관성 표현.

**[일관성 모델]**

- 강한 일관성
- 약한 일관성 - 최종 일관성(결국 갱신이 모든 사본에 반영되는 것)

#### 일관성 불일치 해소

최종 일관성과 같이 사용할 경우, 충돌은 클라이언트가 해결해야 한다. 어떻게? **벡터 시계**라는 개념을 이용한다. 벡터 시계는 **충돌 여부**를 파악하며 **데이터의 최신 버전을 구분**해준다.

> 데이터(키-값 쌍)에 메타데이터처럼 붙어 어떤 서버에서 몇 버전의 데이터를 반영했는지를 나타낸다. 예를 들어, S1에서 키가 `user1`인 데이터의 벡터 시계가 `{"S1":5, "S2":8}`인데, S2에서 같은 키의 데이터 벡터 시계가 `{"S1":4, "S2":8}`라면 S2가 S1의 최신 데이터를 동기화할 수 있을 것이다.

> 이렇게 최신 버전이 명확하다면 동기화가 쉽겠지만, 만약 동시에 서로 다른 서버가 같은 데이터를 업데이트하는 충돌이 일어난다면 어떻게 될까? 두 서버로부터 받은 같은 키의 데이터가 각각 `{"S1":4, "S2":1}`, `{"S1":4, "S3":1}`이라고 하자. 이 경우 클라이언트는 두 값을 읽고 데이터 충돌을 감지하게 된다. 클라이언트는 두 버전을 모두 반영하여 충돌을 해소한 뒤, 벡터 시계를 `{"S1":4, "S2":1, "S3":1}`로 바꾼다.

#### 장애 처리

- 장애 감지: 모든 노드들 간 멀티캐스팅 < 가십 프로토콜

- 일시적 장애 처리: 장애 발생 노드 대신 다른 노드가 처리하고, 복구를 위한 쓰기 연산 단서를 남겨둠

- 영구 장애 처리: 반-엔트로피 프로토콜과 머클 트리