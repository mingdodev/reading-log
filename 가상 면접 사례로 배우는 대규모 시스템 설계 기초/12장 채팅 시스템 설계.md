# 채팅 시스템 설계

1:1 채팅, 그룹 채팅, 대규모 그룹의 소통, 음성 채팅 등 핵심 기능을 명확히 한다. 그룹 채팅의 경우 인원 제한을 두며, 메시지 길이 제한을 고려한다. 첨부파일 지원 여부, 사용자 접속 상태 표시, 종단 간 암호화 지원 등을 고려한다.

## 클라이언트-서버 구조

초기 채팅에는 keep-alive 헤더를 사용한 HTTP를 사용했다. 그러나 HTTP 통신의 경우 클라이언트가 서버에게 요청을 보낼 수는 있지만, 그 반대는 어렵다. 다음과 같은 대안이 있다.

- 폴링: `새 메시지가 있나? 아니오` * n

- 롱 폴링: `새 메시지가 있나? ... 연결 대기 ... 네. 새 메시지 반환 또는 타임아웃... 연결 종료` * n

    - 이 방식은 서버가 클라이언트와의 연결 여부에 대해 알 수 없다는 단점이 있다. 메시지를 보내는 클라이언트와 수신하는 클라이언트가 접속한 서버가 다를 수 있다. (로드밸런싱에 의해)

- 웹소켓

    - 비동기 양방향 통신

## 개략적 설계

### 무상태 / 상태 유지 / 제3자 서비스 연동

무상태 서버에서 '서비스 탐색' 서비스를 만들어, 상태 유지가 필요한 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주도록 한다.

채팅 앱에서 푸시 알림 서비스는 매우 중요하다. 제3자 서비스와의 연계 필요

### 고유하며 정렬 가능한 메시지 ID는 어떻게?

앞서 살펴봤던 스노플레이크도 있지만, 메시지 ID는 같은 채널 또는 같은 채팅 세션 내에서만 유지되면 되기 때문에 지역적 순서 번호 생성기를 이용할 수 있다.

## 상세 설계

### 서비스 탐색: 클라이언트에게 가장 적합한 채팅 서버 추천하기

아파치 주키퍼 등으로 클라이언트의 위치, 서버 용량 등을 고려해 추천한다.

사용자가 시스템에 로그인을 시도하면, 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보내고, 인증이 처리되고 나면 서비스 탐색 기능이 동작하여 해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.

### 종단 간 메시지 흐름: 그렇다면 서로 다른 채팅 서버 간 통신은 어떻게?

메시지 동기화 큐를 사용해, 접속 중인 사용자가 연결한 채팅 서버로 보내거나 미접속 사용자에게는 푸시 알림 서버를 통해 전달한다.

사용자가 채팅 서버 1로 메시지를 보내면 ID 생성기로 메시지 ID를 결정하고, 이 메시지를 동기화 큐로 전송한다. 메시지가 키-값 저장소에 보관된 뒤, 큐를 통해 접속/미접속 사용자에게 서로 다른 작업을 수행한다.

> 메시지 큐(메시지 브로커 kafka, rabbitMQ 등) 토픽으로 채널/채팅방을 구분한다. 메시지 큐가 엄청 많아지겠네.. 라고 생각했는데, 메시지 큐는 단지 주소표에 가까운 개념. 가벼움.

> 단체 채팅의 경우, 메시지 동기화 큐가 사람마다 필요함. 또한 이 메시지 동기화 큐는 여러 사용자의 메시지를 수신해야 함. 그러나 이 방식은 너무 많은 큐를 필요로 한다. 실제로 '안 읽은 메시지 개수'는 각자가 채팅방 별로 어디까지 읽었는지 기록해서 구현하고, 미접속 중 수신하는 메시지는 분기에 의해 푸시 알림으로 오는 걸로 구현.