# 4장 클래스와 인터페이스

- [15. 클래스와 멤버의 접근 권한을 최소화하라](#15-클래스와-멤버의-접근-권한을-최소화하라)

<br>

---

## 15. 클래스와 멤버의 접근 권한을 최소화하라

정보은닉의 장점은 **높은 독립성**에 있다. 외부에 거의 의존하지 않는 컴포넌트는 **재사용성**이 높으며 전체 시스템이 완성되기 전에도 해당 컴포넌트의 동작을 검증할 수 있다.

정보 은닉을 위해 **접근 제한자**를 활용해야 한다. 모든 클래스와 멤버에게 최소한의 접근성을 부여해야 한다. _단, 제대로 동작하는 수준에서_

### 톱레벨 클래스, 인터페이스

#### public

- 공개 API
- 문서화 필요

#### package-private

- 내부 구현

<br>

하나의 클래스에서만 쓰는 `package-private`은 내부로 넣어 `private static`으로 만들자.

> 왜 staic인가? 이 행위가 객체의 행위가 아님을 명시하는 것이다.

<br>

구체적으로는 이런 예시를 들 수 있다.

```java
// package-private helper
class Helper {
    static int calc(int x) { ... }
}
```
어떤 헬퍼 메서드가 특정 톱레벨 클래스에서만 쓰인다.

```java
class Main {
    private static int calc(int x) { ... }
}
```
그렇다면 해당 톱레벨 클래스 내부로 넣자.
static 메서드는 Main 클래스의 **상태와 관련이 없다.** 따라서 불필요하게 인스턴스를 생성할 필요도 없다.
단순히 구현 조각에 가까울 때, 테스트에서 교체가 필요 없는 내부 도구 로직일 때.

### public 클래스의 멤버

- 공개 API가 아닌 부분은 `private`
- 다른 패키지에서 사용하는 부분만 `package-private`
- `public` 클래스의 `protected` 멤버는 **공개 API**다. 영원히 지원되어야 한다.

상위 클래스의 메서드를 재정의할 때에는 이미 접근성의 하한이 정해진다.  _하위 클래스 인스턴스가 상위 클래스 인스턴스를 대체 가능해야 한다는 리스코프 치환의 원칙_
인터페이스는 접근성이 `public`으로 고정되므로, 이를 구현한 메서드의 접근 제한자는 `public`이다.

### public 클래스의 필드

인스턴스 필드는 `public`을 피해야 한다.

- 객체의 상태를 외부에 직접 노출시켜 **불변성, 스레드 안전성, 구현 변경 가능성**을 깨뜨린다.

정적 필드도 마찬가지이다. 그러나 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 상수라면 `public static final`로 공개해도 좋다. 기본 값이나 불변 객체를 참조해야 한다.

```java
public class OrderPolicy {
    public static final int MAX_ORDER_QUANTITY = 100;
}
```
- 주문 도메인의 최대 주문 수량은 주문 정책의 핵심 규칙이며, 숨길 이유가 없다.
- 값이 바뀌면 정책이 바뀐 것

> 단 public static final 배열 필드는 요소 수정이 가능하니 직접 공개해서는 안 된다. `Collections.unmodifiableList()`를 이용하거나 복사본을 public으로 반환하는 방식을 취할 것

### 모듈 시스템

자바 9의 모듈 시스템(module-info.java)를 통해 공개할 클래스를 지정할 수 있다.

<br>

```
💡 필요한 API만 의도적으로 외부에 공개하자. 이는 문서화가 필요하며 지속적으로 제공되어야 한다. 내부 구현은 숨기자.
```

<br>

---

## 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

`public` 클래스는 가변 필드를 직접 노출해서는 안 된다.

단 `package-private` 클래스, `private` 중첩 클래스라면 데이터 필드를 노출해도 큰 문제가 없다.

- 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 한다. 그러나 클라이언트도 해당 패키지 내부 구현의 일부에 불과하기 때문이다.
- 생성자, getter, setter를 추가하는 것이 오히려 불필요한 복잡성을 만들 수 있다.

<br>

---

## 17. 변경 가능성을 최소화하라

### 왜 불변 객체가 좋은가

- 불변 객체는 근본적으로 스레드 안전하다.
- 공유해도 안전하고, 방어적 복사가 필요 없다.
- 불변식(invariant)을 항상 보장한다.
- 설계와 추론이 단순해진다.

### 불변 클래스를 만드는 방법

클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

#### 1. 생성과 확장 제한

- 클래스를 `final`로 선언해 상속을 막는다.
- 또는 생성자를 `package-private, private`으로 두고 `public` 정적 팩토리 메서드를 제공한다.

#### 2. 상태 변경 차단

- 필요한 경우가 아니라면 클라이언트가 내부 상태를 변경할 여지를 제거한다.
- 모든 필드는 `private final`로 선언한다.
- setter를 제공하지 않는다.

#### 3. 가변 객체 차단

- 가변 객체 필드를 가질 경우 외부 클라이언트가 이에 대한 참조를 얻을 수 없게 해야 한다.
    - 접근자에서 내부 객체를 그대로 반환하지 않는다.
    - 생성자에서 방어적 복사

### 불변 객체의 동작 방식

```java
public final class Complex {
    private final double re;
    private final double mi;

    public Complex(double re, double mi) {
        this.re = re;
        this.mi = mi;
    }

    public double realPart() { return re; }
    public double imaginaryPart() { return mi; }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, mi + c.mi);
    }

    // ... equals, hashCode, toString 재정의
}
```

- 상태에 의존하지 않는다.
- 상태를 변경하는 대신 **새 인스턴스를 반환**한다.
- 이런 메서드는:
    - 변경을 암시하는 동사(`add`)보다는 **결과 값을 드러내는 네이밍**(`plus`)을 사용하여 불변을 드러낸다.
    - 피연산자를 변경하지 않는 **함수형 프로그래밍**

### 성능과 최적화

불변 객체는 객체 생성을 많이 유발할 수 있다. 따라서

- 자주 쓰는 인스턴스는 캐싱한다.
    - `private static final` 상수로 미리 만들어 재사용한다.
    - 정적 팩토리를 통해 캐싱된 인스턴스를 반환한다. (예. `Integer.valueOf(10)`)

- **가변 동반 클래스**를 제공한다.
    - 다단계 연산을 하나의 가변 객체에서 처리해 중간 불변 객체 생성을 줄인다.
    - 예. `String`의 `StringBuilder`
