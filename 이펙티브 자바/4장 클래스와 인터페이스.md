# 4장 클래스와 인터페이스

- [15. 클래스와 멤버의 접근 권한을 최소화하라](#15-클래스와-멤버의-접근-권한을-최소화하라)
- [16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
- [17. 변경 가능성을 최소화하라](#17-변경-가능성을-최소화하라)
- [18. 상속보다는 컴포지션을 사용하라](#18-상속보다는-컴포지션을-사용하라)

<br>

---

## 15. 클래스와 멤버의 접근 권한을 최소화하라

정보은닉의 장점은 **높은 독립성**에 있다. 외부에 거의 의존하지 않는 컴포넌트는 **재사용성**이 높으며 전체 시스템이 완성되기 전에도 해당 컴포넌트의 동작을 검증할 수 있다.

정보 은닉을 위해 **접근 제한자**를 활용해야 한다. 모든 클래스와 멤버에게 최소한의 접근성을 부여해야 한다. _단, 제대로 동작하는 수준에서_

### 톱레벨 클래스, 인터페이스

#### public

- 공개 API
- 문서화 필요

#### package-private

- 내부 구현

<br>

하나의 클래스에서만 쓰는 `package-private`은 내부로 넣어 `private static`으로 만들자.

> 왜 staic인가? 이 행위가 객체의 행위가 아님을 명시하는 것이다.

<br>

구체적으로는 이런 예시를 들 수 있다.

```java
// package-private helper
class Helper {
    static int calc(int x) { ... }
}
```
어떤 헬퍼 메서드가 특정 톱레벨 클래스에서만 쓰인다.

```java
class Main {
    private static int calc(int x) { ... }
}
```
그렇다면 해당 톱레벨 클래스 내부로 넣자.
static 메서드는 Main 클래스의 **상태와 관련이 없다.** 따라서 불필요하게 인스턴스를 생성할 필요도 없다.
단순히 구현 조각에 가까울 때, 테스트에서 교체가 필요 없는 내부 도구 로직일 때.

### public 클래스의 멤버

- 공개 API가 아닌 부분은 `private`
- 다른 패키지에서 사용하는 부분만 `package-private`
- `public` 클래스의 `protected` 멤버는 **공개 API**다. 영원히 지원되어야 한다.

상위 클래스의 메서드를 재정의할 때에는 이미 접근성의 하한이 정해진다.  _하위 클래스 인스턴스가 상위 클래스 인스턴스를 대체 가능해야 한다는 리스코프 치환의 원칙_
인터페이스는 접근성이 `public`으로 고정되므로, 이를 구현한 메서드의 접근 제한자는 `public`이다.

### public 클래스의 필드

인스턴스 필드는 `public`을 피해야 한다.

- 객체의 상태를 외부에 직접 노출시켜 **불변성, 스레드 안전성, 구현 변경 가능성**을 깨뜨린다.

정적 필드도 마찬가지이다. 그러나 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 상수라면 `public static final`로 공개해도 좋다. 기본 값이나 불변 객체를 참조해야 한다.

```java
public class OrderPolicy {
    public static final int MAX_ORDER_QUANTITY = 100;
}
```
- 주문 도메인의 최대 주문 수량은 주문 정책의 핵심 규칙이며, 숨길 이유가 없다.
- 값이 바뀌면 정책이 바뀐 것

> 단 public static final 배열 필드는 요소 수정이 가능하니 직접 공개해서는 안 된다. `Collections.unmodifiableList()`를 이용하거나 복사본을 public으로 반환하는 방식을 취할 것

### 모듈 시스템

자바 9의 모듈 시스템(module-info.java)를 통해 공개할 클래스를 지정할 수 있다.

<br>

```
💡 필요한 API만 의도적으로 외부에 공개하자. 이는 문서화가 필요하며 지속적으로 제공되어야 한다. 내부 구현은 숨기자.
```

<br>

---

## 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

`public` 클래스는 가변 필드를 직접 노출해서는 안 된다.

단 `package-private` 클래스, `private` 중첩 클래스라면 데이터 필드를 노출해도 큰 문제가 없다.

- 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 한다. 그러나 클라이언트도 해당 패키지 내부 구현의 일부에 불과하기 때문이다.
- 생성자, getter, setter를 추가하는 것이 오히려 불필요한 복잡성을 만들 수 있다.

<br>

---

## 17. 변경 가능성을 최소화하라

### 왜 불변 객체가 좋은가

- 불변 객체는 근본적으로 스레드 안전하다.
- 공유해도 안전하고, 방어적 복사가 필요 없다.
- 불변식(invariant)을 항상 보장한다.
- 설계와 추론이 단순해진다.

### 불변 클래스를 만드는 방법

클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

#### 1. 생성과 확장 제한

- 클래스를 `final`로 선언해 상속을 막는다.
- 또는 생성자를 `package-private, private`으로 두고 `public` 정적 팩토리 메서드를 제공한다.

#### 2. 상태 변경 차단

- 필요한 경우가 아니라면 클라이언트가 내부 상태를 변경할 여지를 제거한다.
- 모든 필드는 `private final`로 선언한다.
- setter를 제공하지 않는다.

#### 3. 가변 객체 차단

- 가변 객체 필드를 가질 경우 외부 클라이언트가 이에 대한 참조를 얻을 수 없게 해야 한다.
    - 접근자에서 내부 객체를 그대로 반환하지 않는다.
    - 생성자에서 방어적 복사

### 불변 객체의 동작 방식

```java
public final class Complex {
    private final double re;
    private final double mi;

    public Complex(double re, double mi) {
        this.re = re;
        this.mi = mi;
    }

    public double realPart() { return re; }
    public double imaginaryPart() { return mi; }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, mi + c.mi);
    }

    // ... equals, hashCode, toString 재정의
}
```

- 상태에 의존하지 않는다.
- 상태를 변경하는 대신 **새 인스턴스를 반환**한다.
- 이런 메서드는:
    - 변경을 암시하는 동사(`add`)보다는 **결과 값을 드러내는 네이밍**(`plus`)을 사용하여 불변을 드러낸다.
    - 피연산자를 변경하지 않는 **함수형 프로그래밍**

### 성능과 최적화

불변 객체는 객체 생성을 많이 유발할 수 있다. 따라서

- 자주 쓰는 인스턴스는 캐싱한다.
    - `private static final` 상수로 미리 만들어 재사용한다.
    - 정적 팩토리를 통해 캐싱된 인스턴스를 반환한다. (예. `Integer.valueOf(10)`)

- **가변 동반 클래스**를 제공한다.
    - 다단계 연산을 하나의 가변 객체에서 처리해 중간 불변 객체 생성을 줄인다.
    - 예. `String`의 `StringBuilder`

<br>

---

## 18. 상속보다는 컴포지션을 사용하라

상속은 코드 재사용을 쉽게 해 주지만, 상위 클래스의 내부 구현에 하위 클래스가 의존하게 만들어 캡슐화를 깨뜨린다.
그 결과, 상위 클래스의 구현 방식이나 변경 사항이 하위 클래스의 동작에 직접적인 영향을 미치며, 이는 예측하기 어려운 오류로 이어질 수 있다.

이러한 문제는 상속 구조에서 주로 다음 세 가지 경우로 나타난다.

### 1. 하위 클래스가 메서드를 재정의한 경우

상위 클래스의 메서드가 자기 자신의 다른 메서드를 내부에서 호출하는 구조라면,
하위 클래스에서 해당 메서드를 재정의했을 때 의도하지 않은 중복 동작이 발생할 수 있다.

이 문제는 상위 클래스의 내부 구현을 알지 못한 상태에서는 예측하기 어렵고,
해당 구현은 문서화 대상도 아니며 버전 변경 시 유지된다는 보장도 없다.

### 2. 상위 클래스에 새로운 메서드가 추가된 경우

상위 클래스에 새로운 기능이 추가되면,
하위 클래스는 이를 알지 못한 채 상속받게 된다.

특히 보안, 검증, 불변성 유지와 관련된 로직이 필요한 경우,
하위 클래스가 이를 고려하지 못하면 의도치 않은 동작이나 보안 취약점이 생길 수 있다.

### 3. 재정의하지 않고 새 메서드를 추가한 경우

재정의를 피하기 위해 하위 클래스에 새로운 메서드를 추가하더라도,
이 메서드가 추후 상위 클래스에 동일한 시그니처로 추가되면 문제가 발생한다.

이 경우 컴파일 오류 또는 의미가 다른 메서드 충돌이 발생하며,
이는 상속 구조 자체가 상위 클래스의 진화에 취약함을 보여준다.

<br>

상속은 강력하지만 부모 클래스의 구현 세부사항과 변화에 지나치게 민감하다.
따라서 기존 클래스를 확장하고 싶을 때는,
상속보다는 **컴포지션(위임)**을 사용해 내부 구현과의 결합을 최소화하는 것이 바람직하다.

### 컴포지션(Composition)이란?

새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 한다.

> 기존 클래스가 새로운 클래스의 구성(composition) 요소가 됨

전달 메서드(새 클래스의 메서드)가 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다. 이를 통해 새로운 클래스가 기존 클래스의 구현에 의존하지 않게 된다.

#### 래퍼 클래스 예시 (데코레이터 패턴)

- 재사용할 수 있는 전달 클래스

```java
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    public ForwardingSet(Set<E> s) {
        this.s = s;
    }

    // ... 일부 생략

    @Override
    public Iterator<E> iterator() {
        return s.iterator();
    }

    @Override
    public boolean add(E e) {
        return s.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        return s.addAll(c);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}
```

<br>

- 래퍼 클래스

```java
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }
}
```

<br>

상속 기반 확장에서는 상위 클래스 메서드가 내부에서 재정의된 메서드를 다시 호출하면서, 실제 호출 대상이 하위 클래스가 되어 의도치 않은 중복 동작이 발생할 수 있다.
컴포지션 방식에서는 모든 작업을 래퍼가 아닌 **실제 내부 객체**에 위임하므로, 내부 메서드 호출 역시 해당 객체에서만 수행된다.
이로 인해 **메서드 호출 경로가 명확**해지고, 구현 세부 사항에 의존하는 버그를 효과적으로 방지할 수 있다.

#### 래퍼 클래스는 콜백과 어울리지 않는다 (SELF 문제)

래퍼 클래스는 단점이 거의 없지만,
내부 객체가 `this`를 외부로 넘기는 콜백 구조에서는
래퍼가 무력화될 수 있다.

내부 객체는 자신을 감싸는 래퍼의 존재를 모르기 때문에 자신(this)의 참조를 넘기기 때문이다. 이로 인해 콜백 때 래퍼가 아닌 내부 객체를 호출하게 되어 의도와 다르게 동작하게 된다.